/* -----------------------------------------------------------------------------*//* Define the universal genetic code   here's how numeric codes translate to aminoacids 	 	0 == Phe 	1 == Leu 	2 == Ile 	3 == Met 	4 == Val 	5 == Ser 	6 == Pro 	7 == Thr 	8 == Ala 	9 == Tyr 	10 == Stop 	11 == His 	12 == Gln 	13 == Asn 	14 == Lys 	15 == Asp 	16 == Glu 	17 == Cys 	18 == Trp 	19 == Arg 	20 == Gly 	 	AAA,AAC,AAG....TTA,TTC,TTG,TTT - 64 all in all*/				/* defines model states which are not allowed, i.e. termination codons.   GeneticCodeExclusions string is used by DataSetFilter to   eliminate "illegal" states from the data */UniversalGeneticCode = {				{14,/*AAA*/ 13,/*AAC*/ 14,/*AAG*/  13,/*AAT*/		  7, /*ACA*/ 7, /*ACC*/ 7, /*ACG*/  7, /*ACT*/		 19, /*AGA*/ 5, /*AGC*/19, /*AGG*/  5, /*AGT*/		  2, /*ATA*/ 2, /*ATC*/	3, /*ATG*/  2, /*ATT*/		 12,/*CAA*/ 11,/*CAC*/ 12,/*CAG*/  11,/*CAT*/		  6, /*CCA*/ 6, /*CCC*/ 6, /*CCG*/  6, /*CCT*/		 19,/*CGA*/ 19,/*CGC*/ 19,/*CGG*/  19,/*CGT*/		  1, /*CTA*/ 1, /*CTG*/ 1, /*CTC*/  1, /*CTT*/		 16,/*GAA*/ 15,/*GAC*/ 16,/*GAG*/  15,/*GAT*/		  8, /*GCA*/ 8, /*GCC*/ 8, /*GCG*/  8, /*GCT*/		 20,/*GGA*/ 20,/*GGC*/ 20,/*GGG*/  20,/*GGT*/		  4, /*GTA*/ 4, /*GTC*/ 4, /*GTG*/  4, /*GTT*/		 10,/*TAA*/  9, /*TAC*/10,/*TAG*/   9, /*TAT*/		  5, /*TCA*/ 5, /*TCC*/ 5, /*TCG*/  5, /*TCT*/		 10,/*TGA*/ 17,/*TGC*/ 18,/*TGG*/  17,/*TGT*/		  1, /*TTA*/ 0, /*TTC*/ 1, /*TTG*/  0  /*TTT*/ }	    };/* -----------------------------------------------------------------------------   Define a function which builds codon frequencies from nucleotide counts, using the formula:                       Freq[nuc i in position 1] * Freq[nuc j in position 2] * Freq[nuc k in position 3]  Freq(codon ijk) = -----------------------------------------------------------------------------------                                  1 - sum of estimated stop codon frequencies                            */function BuildCodonFrequencies (nucFreqMatrix){		PIStop = 1.0; 		/* denominator */	result = {61,1};    /* resulting codon frequencies */	hshift = 0;         /* how many stop codons have been counted so far */	for (h=0; h<64; h=h+1) /* loop over all possible codons */	{		first  = h$16;    /* Decompose a codon into 3 nucleotides. 							 The index of the first nucleotide (A=0,C=1,G=2,T=3) is found here,							 by doing integer division by 16  */		second = h%16$4;  /* The index of the second nucleotide. 							 First take the remainder of division by 16, i.e. positions 2 and 3							 and then extract position 2 by integer division by 4*/		third  = h%4;     /* The index of the third nucleotide.							 Remainder of integer division by 4*/							 						  /* in the end: h = 16*first + 4*second + third */							 		if (UniversalGeneticCode[h]==10) /* stop codon */ 		{			hshift = hshift+1; 			PIStop = PIStop-nucFreqMatrix[first][0]*nucFreqMatrix[second][1]*nucFreqMatrix[third][2]; /* adjust the denominator */		}		else		{			result[h-hshift] = nucFreqMatrix[first][0]*nucFreqMatrix[second][1]*nucFreqMatrix[third][2]; 											/* store the frequency for codon h. Notice the substraction of hshift to compensate											  for the absense of stop codons. The first codon affected by it is 											  TAC (h=49), which gets stored in result[48], because TAA (a stop codon) was skipped. */		}	}	return result*(1.0/PIStop);}/* -----------------------------------------------------------------------------*//* Read and filter the data */DataSet 			myData		 = ReadDataFile ("../p51.nex");DataSetFilter 		codonFilter  = CreateFilter	(myData,3,"","","TAA,TAG,TGA"); /* define the codon filter, excluding stop codons */HarvestFrequencies  (nuc3by4,myData,3,1,1); 			     /* collect position specific nucleotide frequencies */HarvestFrequencies  (observedCodonFreqs,myData,3,3,0);       /* collect observed codon counts.*/fprintf (stdout, "\n\nThis is a sample HyPhy batch file. Written by Sergei L Kosakovsky Pond (spond@ucsd.edu)\n",				 "\nRead an alignment of ", codonFilter.species, " sequences with ", codonFilter.sites, " codon sites.");				 /* print out codon frequencies estimated from nucleotides, and observed. Note that    some non-stop codons are not observed at all! This is why estimating codon frequencies   from the data is, in general, a bad idea!    Notice the trick to generate codon strings from their codes    and formatting code.*/   estimatedCodonFreqs = BuildCodonFrequencies(nuc3by4);   nucLetters = "ACGT"; hshift     = 0;fprintf (stdout, "\nComparing estimated and observed codon frequencies\n\n",				 "|Index|Corrected Index|Codon|Observed|Estimated|\n");for (h=0; h<64; h=h+1) /* loop over all possible codons */{	if (UniversalGeneticCode[h]==10) /* stop codon */ 	{		hshift = hshift+1;	} 	else	{			first  = h$16;   		second = h%16$4;  		third  = h%4;     							 		fprintf (stdout, "|",Format(h,5,0),"|",Format(h-hshift,15,0),"| ",nucLetters[first]+nucLetters[second]+nucLetters[third]," |", 							   Format(observedCodonFreqs[h],8,4),"|",Format (estimatedCodonFreqs[h-hshift],9,4),"|\n");	}}/* -----------------------------------------------------------------------------   Define rate variation variables - one for synonymous, and one for    non-synonymous rates. Both are discretized unit gammas, with independently   estimated shape parameters and 4 categories.   */global alpha_syn = 2;alpha_syn:>0.01; alpha_syn:<100;category S  = (4, EQUAL, MEAN, GammaDist(_x_,alpha_syn,alpha_syn), CGammaDist(_x_,alpha_syn,alpha_syn),0,1e25,CGammaDist(_x_,alpha_syn+1,alpha_syn));global alpha_nonsyn=0.5;alpha_nonsyn:>0.01; alpha_nonsyn:<100;category NS = (4, EQUAL, MEAN, GammaDist(_x_,alpha_nonsyn,alpha_nonsyn), CGammaDist(_x_,alpha_nonsyn,alpha_nonsyn),0,1e25,CGammaDist(_x_,alpha_nonsyn+1,alpha_nonsyn)*alpha_nonsyn/alpha_nonsyn);global   R  	= 1; /* global dN/dS ration */global   kappa	= 1; /* global transversion/transition ratio *//* -----------------------------------------------------------------------------   Now we populate the transition matrix for MG94xHKY85 model.   We use the fact that the matrix is almost symmetric (up to frequency terms),   to only looping over above the diagonal elements */   MG94xHKY85RateMatrix = {61,61};hshift = 0;for (h=0; h<63; h=h+1){	if (UniversalGeneticCode[h] == 10) /* stop codon */	{		hshift = hshift + 1;	}	else	{		vshift = hshift;		for (v=h+1; v<64; v=v+1) 		{			if (UniversalGeneticCode[v] == 10)  /* stop codon */			{				vshift = vshift + 1;			}			else			{				/* We must determine how many subsitutions are needed to get from codon h to codon v.				   Only pairs with exactly one substitution are assigned non-zero rates.				   				   Two codons indexed by h and v differ in a single nucleotide position if and only if one of the following conditions 				   are met:				   				   1). h$4==v$4 (same result of integer division by 4), the change is in the third position				   2). (v-h)%16 is 0 (same remainder of integer division by 16), the change is in the first position				   3). (h$16==v$16) and (v-h)%4 is 0 (same result of integer division by 16 and same remainder by integer division by 4), the change in the second position				   				   This is pretty obtuse but not too difficult to work out.				   				*/								diff = v-h;								if ((h$4==v$4)||((diff%4==0)&&(h$16==v$16))||(diff%16==0)) /* differ by one subsitution only */				{					if (h$4==v$4) /* third position */					{						transition = v%4; /* get targets nucleotides for h->v and v->h substitutions */						transition2= h%4;						nucPosInCodon = 2; /* change is in the third position */					}					else					{						if(diff%16==0) /* first position */						{							transition = v$16; /* get targets nucleotides for h->v and v->h substitutions */							transition2= h$16;							nucPosInCodon = 0; /* change is in the first position */						}						else						{							transition = v%16$4; /* get targets nucleotides for h->v and v->h substitutions */							transition2= h%16$4;							nucPosInCodon = 1;  /* change is in the second position */						}					}										/* in the assignments below, note the use of double underscore '__' to 					   replace the variable with its numerical value in the formula. We need					   to do that to prevent spurious dependencies of rate matrix elements on					   utility variables transition, transition2 and nucPosInCodon. Also, 					   we don't want the dependency on the matrix nuc3by4.  */					   					if (UniversalGeneticCode[h]==UniversalGeneticCode[v]) /* synonymous */					{			  			if (Abs(transition-transition2)%2) /* transversion: difference is not divisible by 2 */			  			{							MG94xHKY85RateMatrix[h-hshift][v-vshift] := S*t*kappa*nuc3by4__[transition__][nucPosInCodon__];							MG94xHKY85RateMatrix[v-vshift][h-hshift] := S*t*kappa*nuc3by4__[transition2__][nucPosInCodon__];			  			}			  			else /* transition */			  			{							MG94xHKY85RateMatrix[h-hshift][v-vshift] := S*t*nuc3by4__[transition__][nucPosInCodon__];							MG94xHKY85RateMatrix[v-vshift][h-hshift] := S*t*nuc3by4__[transition2__][nucPosInCodon__];			  			}					}					else /* non-synonymous */					{			  			if (Abs(transition-transition2)%2) /* transversion: difference is not divisible by 2 */			  			{							MG94xHKY85RateMatrix[h-hshift][v-vshift] := NS*R*t*kappa*nuc3by4__[transition__][nucPosInCodon__];							MG94xHKY85RateMatrix[v-vshift][h-hshift] := NS*R*t*kappa*nuc3by4__[transition2__][nucPosInCodon__];			  			}			  			else /* transition */			  			{							MG94xHKY85RateMatrix[h-hshift][v-vshift] := NS*R*synRate*nuc3by4__[transition__][nucPosInCodon__];							MG94xHKY85RateMatrix[v-vshift][h-hshift] := NS*R*synRate*nuc3by4__[transition2__][nucPosInCodon__];			  			}					}				}							}		}	}}/* construct the model. Note the '0' argument at the end to prevent automatic multiplication   of rate matrix elements by target frequencies (from estimatedCodonFreqs in this case )*/Model MG94xHKY85 = (MG94xHKY85RateMatrix,estimatedCodonFreqs,0);Tree myTree = DATAFILE_TREE; /* use the tree string from the data file */LikelihoodFunction lf = (codonFilter, myTree);Optimize (myRes, lf); /* this optimization takes a while - 15 minutes on a dual Mac G5 */fprintf (stdout, "\n", lf, "\n");ConstructCategoryMatrix (catMatrix, lf, COMPLETE); /* Obtain the matrix of marginal likelihoods and rate distributions */GetInformation			(synDist, S);GetInformation			(nonsynDist, NS); SetDialogPrompt			("Save marginal likelihoods to:");/* store all the information in a format suitable for processing by 2RatesAnalysis/ResultProcessor.bf    with the M3 option. This file is useful for finding sites under positive selection etc       Note the use of 'CLEAR_FILE' to erase previous contents of the selected file */   fprintf					(PROMPT_FOR_FILE,CLEAR_FILE,synDist,"\n",nonsynDist,"\n",catMatrix);  			 				 